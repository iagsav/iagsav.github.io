
R version 3.2.2 (2015-08-14) -- "Fire Safety"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R -- это свободное ПО, и оно поставляется безо всяких гарантий.
Вы вольны распространять его при соблюдении некоторых условий.
Введите 'license()' для получения более подробной информации.

R -- это проект, в котором сотрудничает множество разработчиков.
Введите 'contributors()' для получения дополнительной информации и
'citation()' для ознакомления с правилами упоминания R и его пакетов
в публикациях.

Введите 'demo()' для запуска демонстрационных программ, 'help()' -- для
получения справки, 'help.start()' -- для доступа к справке через браузер.
Введите 'q()', чтобы выйти из R.

[Загружено ранее сохраненное рабочее пространство]

> rm(list = ls())
> gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 250793 13.4     592000 31.7   592000 31.7
Vcells 357077  2.8    1599226 12.3  1263376  9.7
> 
> MyNorm = function(data)
+ {
+   data <- data - min(data)
+   data <- data / max(data)
+   
+ }
> 
> # поиск изображения в дереве + функции по искажению изображения
> library(data.tree)
> library(jpeg)
> library(EBImage)
> 
> source("buildDec.R")
> source("buildUimg.R")
> source("imshow.R")
> 
> procdir <- '/home/vgai/result/'
> 
> 
> #fls <- list.files(procdir, pattern = "\\.jpg$", ignore.case = TRUE)
> #flsdec <- list.files(procdir, pattern = "\\FL.rdata$", ignore.case = TRUE)
> 
> snrs <- c(20, 10, 0)
> starts <- 1
> prval <- c(seq(0.01, 1, 0.01))
> 
> load('fls.rdata')
> load('flsdec.rdata')
> load('resTree.rdata')
> 
> library(foreach)
> library(doMC)
Загрузка требуемого пакета: iterators
Загрузка требуемого пакета: parallel
> registerDoMC(8)  #change the 2 to your number of CPU cores  
> 
> load('fo.rdata')
> N <- 3
> 
> # индекс искомого изображения
> # здесь должен начинаться цикл
> thr <- 1
> 
> angleind = c(seq(from = 1, to = 90, by = 1), seq(from = -90, to = -1, by = 1))
> 
> system.time(ddd <- foreach(imInd = seq(from = 1, to = 50000, by = 500), .packages = 'jpeg', .export = c('imTree', 'fls', 'flsdec')) %dopar% # %dopar%
+ {              
+   print(imInd)
+   err1 <- matrix(0, 1, 2*length(angleind))
+   somesnr <- c()
+ 
+   img <- readJPEG(paste(procdir, fls[[imInd]], sep = ""))
+   
+   if (length(dim(img)) == 3)
+   {
+     img <- img[,,1] + img[,,2] + img[,,3];
+   }  
+   
+   # нормализация изображения по амплитуде к [0; 1]
+   img <- MyNorm(img)
+   
+   # формирование искажённого изображения
+   
+   
+   for (angle in 1:length(angleind))
+   {
+     # формирование искажённого изображения
+         
+     dimg <- rotate(img, angleind[angle], bg.col = 0, output.dim = dim(img))
+     
+     dimg <- MyNorm(dimg)
+     
+     ddec <- buildDec(dimg, N, flt, oper)
+     
+     # поиск изображения в базе
+     rind <- c()
+     for (j in 1:N)
+     {
+       # определяем максимум на j-ом уровне по каким-то своим признакам
+       tmp <- matrix(0, length(ddec[[j]]), 15)
+       for (k in 1:length(ddec[[j]]))
+       {
+         tmp[k,] <- ddec[[j]][[k]][[1]][1:15]
+       }
+       
+       imax <- which(abs(tmp) == max(abs(tmp)), arr.ind = TRUE)
+       
+       iind <- imax[2]
+       if (tmp[imax] < 0)
+       {
+         iind <- iind + 15
+       }
+       # iind - адрес узла на i-ом уровне разложения
+       
+       rind <- c(rind, iind)
+     }
+     
+     pref <- "imTree"
+     for (j in 1:length(rind))
+     {
+       pref <- paste(pref, sprintf('$children[[%d]]', rind[j]) ,sep = "")  
+     }
+     commStr <- paste(pref, "$myData", sep = "")
+     
+     # предварительный список изображений
+     imList <- eval(parse(text = commStr))
+     
+     # груба оценка точности поиска
+     zres <- which(imList == imInd)
+     if (length(zres) == 0)
+     {
+       err1[angle + length(angleind)] <- err1[angle + length(angleind)] + 1
+     }
+     
+     # сначала надо загрузить описания предварительно найденных файлов
+     flsdec1 <- flsdec[imList]
+     
+     myLev <- 3
+     
+     ldec <- list(0)
+     for (i in 1:length(flsdec1))
+     {
+       # сюда нужен код
+       load(paste(procdir, flsdec1[i], sep = ""))
+       
+       j <- myLev
+       tmpSource <- matrix(0, length(dec[[j]]), 15)
+       for (k in 1:length(dec[[j]]))
+       {
+         tmpSource[k,] <- dec[[j]][[k]][[1]][1:15]
+       }
+       
+       ldec[[i]] <- tmpSource
+     }
+     
+     j <- myLev
+     tmpSource <- matrix(0, length(ddec[[j]]), 15)
+     for (k in 1:length(ddec[[j]]))
+     {
+       tmpSource[k,] <- ddec[[j]][[k]][[1]][1:15]
+     }
+     
+     # окончательный поиск изображения
+     imDiff2 <- c()
+     for (i in 1:length(imList))
+     {
+       # сюда нужен код
+       imDiff2[i] <- sum(abs(sign(tmpSource) - sign(ldec[[i]])))
+     }
+     
+     imax <- which(abs(imDiff2) == min(abs(imDiff2)), arr.ind = TRUE)
+     imax <- imax[1]
+     
+     if (imList[imax] != imInd)
+     {
+       err1[angle] <- err1[angle] + 1
+     } 
+     
+     #print(err1)
+   }
+   save(err1, file = paste(procdir, fls[[imInd]], 'errrotate.rdata', sep = ""))
+   return(err1)
+ })
[1] 1
[1] 501
[1] 1001
[1] 1501
[1] 2001
[1] 2501
[1] 3001
[1] 3501
[1] 6001
[1] 6501
[1] 7501
[1] 10501
[1] 5001
[1] 11501
[1] 5501
[1] 9501
[1] 10001
[1] 7001
[1] 4501
[1] 9001
[1] 4001
[1] 14501
[1] 11001
[1] 15501
[1] 13501
[1] 13001
[1] 14001
[1] 18501
[1] 15001
[1] 8001
[1] 8501
[1] 12001
[1] 12501
[1] 16001
[1] 19001
[1] 19501
[1] 17501
[1] 18001
[1] 22501
[1] 23501
[1] 16501
[1] 22001
[1] 17001
[1] 20001
[1] 24001
[1] 26501
[1] 28001
[1] 27501
[1] 26001
[1] 31501
[1] 30001
[1] 23001
[1] 20501
[1] 27001
[1] 21501
[1] 30501
[1] 35501
[1] 39501
[1] 32001
[1] 34001
[1] 21001
[1] 25001
[1] 24501
[1] 25501
[1] 29001
[1] 36001
[1] 31001
[1] 35001
[1] 40001
[1] 44001
[1] 43501
[1] 38001
[1] 33001
[1] 34501
[1] 29501
[1] 28501
[1] 38501
[1] 39001
[1] 48001
[1] 42001
[1] 46001
[1] 33501
[1] 32501
[1] 47501
[1] 42501
[1] 37001
[1] 43001
[1] 36501
[1] 46501
[1] 37501
[1] 47001
[1] 40501
[1] 41001
[1] 41501
[1] 45001
[1] 45501
[1] 44501
[1] 48501
[1] 49001
[1] 49501
Ошибка в { :task 4 failed - "не могу открыть соединение"
Вызовы: system.time -> %dopar% -> <Anonymous>
Timing stopped at: 76761.43 1221.349 13506.43 
Выполнение остановлено
