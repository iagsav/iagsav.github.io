
R version 3.2.2 (2015-08-14) -- "Fire Safety"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R -- это свободное ПО, и оно поставляется безо всяких гарантий.
Вы вольны распространять его при соблюдении некоторых условий.
Введите 'license()' для получения более подробной информации.

R -- это проект, в котором сотрудничает множество разработчиков.
Введите 'contributors()' для получения дополнительной информации и
'citation()' для ознакомления с правилами упоминания R и его пакетов
в публикациях.

Введите 'demo()' для запуска демонстрационных программ, 'help()' -- для
получения справки, 'help.start()' -- для доступа к справке через браузер.
Введите 'q()', чтобы выйти из R.

[Загружено ранее сохраненное рабочее пространство]

> rm(list = ls())
> gc()
         used (Mb) gc trigger  (Mb) max used  (Mb)
Ncells 250877 13.4     940480  50.3   657347  35.2
Vcells 357150  2.8   32404766 247.3 33602185 256.4
> 
> load('imTree_bin_filled.rdata')
> MyNorm = function(data)
+ {
+   data <- data - min(data)
+   data <- data / max(data)
+ }
> 
> # поиск на основе операторов
> # бинарное дерево
> 
> # поиск изображени в дереве + функции по искажению изображени
> library(data.tree)
> library(jpeg)
> library(EBImage)
> 
> source("buildDec.R")
> source("buildUimg.R")
> source("imshow.R")
> 
> procdir <- '/home/vgai/result/'
> 
> #fls <- list.files(procdir, pattern = "\\.jpg$", ignore.case = TRUE)
> #flsdec <- list.files(procdir, pattern = "\\FL.rdata$", ignore.case = TRUE)
> load('fls.rdata')
> load('flsdec.rdata')
> 
> snrs <- c(20, 10, 0)
> 
> starts <- 1
> #prval <- c(seq(0.001, 3, 0.001))
> prval <- c(seq(0.01, 1, 0.01))
> 
> load('fo.rdata')
> N <- 5
> C1 <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
> C2 <- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)
> 
> library(foreach)
> library(doMC)
Загрузка требуемого пакета: iterators
Загрузка требуемого пакета: parallel
> registerDoMC(14)  #change the 2 to your number of CPU cores  
> 
> 
> angleind = c(seq(from = 1, to = 90, by = 1), seq(from = -90, to = -1, by = 1))
> sind = seq(from = 1, to = 50000, by = 400)
> 
> ddd <- system.time(ddd <- foreach(imInd = sind, .packages = 'jpeg', .export = c('imTree', 'fls', 'flsdec')) %dopar% # %dopar%
+ {  
+   # индекс искомого изображени
+   print(imInd)
+   # начинаем отсюда
+   err1 <- matrix(0, 1, 2*length(angleind))
+   
+   img <- readJPEG(paste(procdir, fls[[imInd]], sep = ""))
+   
+   if (length(dim(img)) == 3)
+   {
+     img <- img[,,1] + img[,,2] + img[,,3];
+   }  
+   
+   # нормализаци изображени по амплитуде к [0; 1]
+   img <- MyNorm(img)
+   
+   for (angle in 1:length(angleind))
+   {
+     # формирование искажённого изображения
+     
+     dimg <- rotate(img, angleind[angle], bg.col = 0, output.dim = dim(img))
+     
+     dimg <- MyNorm(dimg)
+     ddec <- buildDec(dimg, N, flt, oper)
+     
+     rind <- c()
+     
+     # цикл по уровнм
+     for (j in 1:N)
+     {
+       # определем максимум на j-ом уровне по каким-то своим признакам
+       tmp <- matrix(0, length(ddec[[j]]), 15)
+       for (k in 1:length(ddec[[j]]))
+       {
+         tmp[k,] <- ddec[[j]][[k]][[1]][1:15]
+       }
+       
+       imax <- which(abs(tmp) == max(abs(tmp)), arr.ind = TRUE)
+       
+       if (prod(dim(imax)) > 2)
+       {
+         #print(fls[[i]]) 
+         imax <- imax[1,]
+         imax <- as.matrix(imax)
+       }
+       
+       if (prod(dim(imax)) == 2)
+       {
+         # print(fls[[i]]) 
+         imax <- as.matrix(imax)
+       }
+       
+       maxs <- tmp[imax[1], ]    
+       
+       binrep <- matrix(0, 1,30)
+       
+       for (jk in 1:length(maxs))
+       {
+         if (maxs[jk] < 0)
+         {
+           binrep[jk + 15] <- 1
+         }
+         else
+         {
+           binrep[jk] <- 1
+         }
+       }
+       
+       dist1 <- sum(C1 == binrep)
+       dist2 <- sum(C2 == binrep)
+       
+       if (dist1 == dist2)
+       {
+         warning('dist1 == dist2')
+       }
+       
+       if (dist1 > dist2)
+       {
+         rind <- c(rind, 1)      
+       }
+       else
+       {
+         rind <- c(rind, 2)      
+       }
+     }
+     
+     pref <- "imTree"
+     for (j in 1:length(rind))
+     {
+       pref <- paste(pref, sprintf('$children[[%d]]', rind[j]) ,sep = "")  
+     }
+     commStr <- paste(pref, "$myData", sep = "")
+     
+     # предварительный список изображений
+     imList <- eval(parse(text = commStr))
+     
+     zres <- which(imList == imInd)
+     if (length(zres) == 0)
+     {
+       err1[angle + length(angleind)] <- err1[angle + length(angleind)] + 1
+     }
+     
+     # сначала надо загрузить описани предварительно найденных файлов
+     flsdec1 <- flsdec[imList]
+     
+     myLev <- 5
+     
+     ldec <- list(0)
+     for (i in 1:length(flsdec1))
+     {
+       # сюда нужен код
+       load(paste(procdir, flsdec1[i], sep = ""))
+       
+       j <- myLev
+       tmpSource <- matrix(0, length(dec[[j]]), 15)
+       for (k in 1:length(dec[[j]]))
+       {
+         tmpSource[k,] <- dec[[j]][[k]][[1]][1:15]
+       }
+       
+       ldec[[i]] <- tmpSource
+     }
+     
+     j <- myLev
+     tmpSource <- matrix(0, length(ddec[[j]]), 15)
+     for (k in 1:length(ddec[[j]]))
+     {
+       tmpSource[k,] <- ddec[[j]][[k]][[1]][1:15]
+     }
+     
+     # окончательный поиск изображени
+     imDiff2 <- c()
+     for (i in 1:length(imList))
+     {
+       # сюда нужен код
+       imDiff2[i] <- sum(abs(sign(tmpSource) - sign(ldec[[i]])))
+     }
+     
+     imax <- which(abs(imDiff2) == min(abs(imDiff2)), arr.ind = TRUE)
+     imax <- imax[1]
+     #print(paste(imList[imax], imInd))
+     if (imList[imax] != imInd)
+     {
+       err1[angle] <- err1[angle] + 1
+     }
+     
+   }
+   save(err1, file = paste(procdir, fls[[imInd]], 'errrotatebin.rdata', sep = ""))
+   return(err1)
+ })
[1] 1
[1] 401
[1] 801
[1] 1201
[1] 1601
[1] 2001
[1] 2401
[1] 2801
[1] 3201
[1] 3601
[1] 4001
[1] 4401
[1] 4801
[1] 5201
[1] 6801
[1] 6401
[1] 10801
[1] 7601
[1] 8001
[1] 8801
[1] 10401
[1] 10001
[1] 9201
[1] 6001
[1] 5601
[1] 7201
[1] 8401
[1] 9601
[1] 12401
[1] 12001
[1] 13601
[1] 13201
[1] 16401
[1] 14401
[1] 15601
[1] 12801
[1] 16001
[1] 14801
[1] 11601
[1] 15201
[1] 14001
[1] 11201
[1] 20001
[1] 18801
[1] 18001
[1] 17601
[1] 19201
[1] 18401
[1] 22001
[1] 20401
[1] 20801
[1] 17201
[1] 19601
[1] 21201
[1] 21601
[1] 16801
[1] 25601
[1] 24001
[1] 24401
[1] 26401
[1] 24801
[1] 23601
[1] 27601
[1] 23201
[1] 26001
[1] 26801
[1] 22801
[1] 22401
[1] 25201
[1] 27201
[1] 29601
[1] 31201
[1] 33201
[1] 32001
[1] 30001
[1] 30401
[1] 29201
[1] 31601
[1] 28801
[1] 32401
[1] 28401
[1] 35201
[1] 28001
[1] 32801
[1] 30801
[1] 38801
[1] 36801
[1] 34801
[1] 37601
[1] 34401
[1] 37201
[1] 36001
[1] 35601
[1] 38001
[1] 34001
[1] 40801
[1] 38401
[1] 33601
[1] 36401
[1] 40401
[1] 40001
[1] 42401
[1] 44401
[1] 41601
[1] 43201
[1] 43601
[1] 41201
[1] 42801
[1] 39601
[1] 44001
[1] 46401
[1] 45601
[1] 42001
[1] 46001
[1] 39201
[1] 49201
[1] 48001
[1] 46801
[1] 48801
[1] 47201
[1] 48401
[1] 49601
[1] 44801
[1] 45201
[1] 47601
> 
> proc.time()
пользователь      система       прошло 
  497422.069     4240.547    40763.272 
